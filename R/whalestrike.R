# vim:textwidth=128:expandtab:shiftwidth=4:softtabstop=4

library(deSolve)

#' Reference strike() solution
#'
#' This was produced with the package as it existed on 2020-jul-8,
#' prior to the publication of Kelley et al. (2020).  It is used
#' in testing, to ensure that the package does not inadvertently
#' change in its predictions.
#'
#' @examples
#' data(sol20200708)
#' par(mfrow = c(1, 3))
#' plot(sol20200708)
#'
#' @references
#'
#' Kelley, Dan E., James P. Vlasic, and Sean W. Brillant. “Assessing the Lethality
#' of Ship Strikes on Whales Using Simple Biophysical Models.” Marine Mammal
#' Science, October 12, 2020, mms.12745. \url{https://doi.org/10.1111/mms.12745}.
#'
#' @name sol20200708
#'
#' @docType data
NULL

#' Whale side-view shape
#'
#' This is a data frame containing 45 points specifying the shape
#' of a right whale, viewed from the side. It was created
#' by digitizing the whale shape (ignoring fins) that is
#' provided in the necropsy reports of Daoust et al. (2018). The
#' data frame contains `x` and `y`, which are distances
#' nondimensionalized by the range in `x`; that is, `x`
#' ranges from 0 to 1. The point at the front of the whale is
#' designated as x=y=0.
#'
#' @references
#'
#' Daoust, Pierre-Yves, Émilie L. Couture, Tonya Wimmer, and Laura Bourque.
#' “Incident Report. North Atlantic Right Whale Mortality Event in the Gulf of St.
#' Lawrence, 2017.” Canadian Wildlife Health Cooperative, Marine Animal Response
#' Society, and Fisheries and Oceans Canada, 2018.
#' \url{http://publications.gc.ca/site/eng/9.850838/publication.html}.
#'
#' @examples
#' library(whalestrike)
#' data(whaleshape)
#' plot(whaleshape$x, whaleshape$y, asp = 1, type = "l")
#' polygon(whaleshape$x, whaleshape$y, col = "lightgray")
#' lw <- 13.7
#' Rmax <- 0.5 * lw * diff(range(whaleshape$y))
#' mtext(sprintf("Max. radius %.2fm for %.1fm-long whale", Rmax, lw), side = 3)
#'
#' @name whaleshape
#'
#' @docType data
NULL


#' whalestrike: A Package to Simulate Ship-Whale Collisions
#'
#' This package solves Newton's second law for a simple model of
#' a ship colliding with a whale. This is a stripped-down model
#' that does not attempt to simulate the biomechanical interactions
#' that can be simulated in finite-element treatments such
#' as that of Raymond (2007).  For an in-depth discussion
#' of the reason for writing the model, of the principles involved
#' in its framing, and its use in developing a criterion for
#' strike lethality, please see Kelley et al. (2020).
#'
#' The goal of the model is to establish a
#' convenient framework for rapid computation of impacts in a
#' wide variety of conditions. The model runs
#' quickly enough to keep up with mouse movements to select
#' conditions, in a companion R shiny app. That app lets
#' the user see the effects of changing contact
#' area, ship speed, etc., as a way to build intuition
#' for scenarios ranging from collision with a slow-moving
#' fishing boat to collision with a thin dagger-board of a
#' much swifter racing sailboat. Another advantage of the
#' simple formulation is that it makes it easy to
#' modify various dynamical and biomechanical parameters,
#' to add new forces, and to explore a range of
#' criteria for whale damage.
#'
#' The documentation for [strike()] provides
#' a practical example of using the main functions of this package,
#' while the package vignette provides a general overview.
#' Kelley et al (2020) provide more
#' detail about the mathematical
#' framework of the package, along with a discussion of its
#' purpose and application to real-world problems of ship
#' strikes on whales.
#'
#' @section Further reading:
#' \itemize{
#'
#' \item
#'
#' Daoust, Pierre-Yves, Émilie L. Couture, Tonya Wimmer, and Laura Bourque.
#' “Incident Report. North Atlantic Right Whale Mortality Event in the Gulf of St.
#' Lawrence, 2017.” Canadian Wildlife Health Cooperative, Marine Animal Response
#' Society, and Fisheries and Oceans Canada, 2018.
#' \url{https://publications.gc.ca/site/eng/9.850838/publication.html}.
#'
#' \item
#' Fortune, Sarah M. E., Andrew W. Trites, Wayne L. Perryman, Michael J. Moore,
#' Heather M. Pettis, and Morgan S. Lynn. “Growth and Rapid Early Development of
#' North Atlantic Right Whales (Eubalaena Glacialis).” Journal of Mammalogy 93,
#' no. 5 (2012): 1342–54. \doi{10.1644/11-MAMM-A-297.1}.
#'
#' \item
#' Grear, Molly E., Michael R. Motley, Stephanie B. Crofts, Amanda E. Witt, Adam
#' P. Summers, and Petra Ditsche. “Mechanical Properties of Harbor Seal Skin and
#' Blubber--a Test of Anisotropy.” Zoology 126 (2018): 137–44.
#' \doi{10.1016/j.zool.2017.11.002}.
#'
#' \item
#' Kelley, Dan E., James P. Vlasic, and Sean W. Brillant. “Assessing the
#' Lethality of Ship Strikes on Whales Using Simple Biophysical Models.” Marine
#' Mammal Science, October 12, 2020, mms.12745.
#' \doi{10.1111/mms.12745}.
#'
#' \item
#' Kelley, Dan E. “Composite Spring,” May 28, 2018. 20180528_composite_string. Dan Kelley’s working notes.
#'
#' \item
#' Kelley, Dan. “Whale Area,” June 23, 2018. 20180623_whale_area. Dan Kelley’s working notes.
#'
#' \item
#' Kelley, Dan. “Ship Propulsion,” July 1, 2018. 20180701_ship_propulsion. Dan Kelley’s working notes.
#'
#' \item
#' Kelley, Dan. “Whale Mass,” July 7, 2018. 20180707_whale_mass. Dan Kelley’s working notes.
#'
#' \item
#' MAN Diesel & Turbo. “Basic Principles of Propulsion.” MAN Diesel & Turbo, 2011.
# nolint start line_length_linter
#' \code{https://spain.mandieselturbo.com/docs/librariesprovider10/sistemas-propulsivos-marinos/basic-principles-of-ship-propulsion.pdf?sfvrsn=2}
# nolint end line_length_linter
#'
#' \item
#' Manen, J. D. van, and P. van Oossanen. “Resistance.” In Principles of Naval
#' Architecture (Second Revision), Volume II - Resistance, Propulsion and
#' Vibration, edited by Edward V Lewis, Second Edition, 1–125. Jersey City, NJ: Society
#' of Naval Architects and Marine Engineers (U.S.), 1988.
#'
#' \item
#' Miller, Carolyn A., Desray Reeb, Peter B. Best, Amy R. Knowlton, Moira W.
#' Brown, and Michael J. Moore. “Blubber Thickness in Right Whales Eubalaena
#' Glacialis and Eubalaena Australis Related with Reproduction, Life History
#' Status and Prey Abundance.” Marine Ecology Progress Series 438 (2011): 267–83.
#'
#' \item
#' Moore, M.J., A.R. Knowlton, S.D. Kraus, W.A. McLellan, and R.K. Bonde.
#' “Morphometry, Gross Morphology and Available Histopathology in North Atlantic
#' Right Whale (Eubalaena Glacialis) Mortalities (1970 to 2002).” Journal of
#' Cetacean Research and Management 6, no. 3 (2005): 199–214.
#'
#' \item
#' Ng, Laurel J., Vladislav Volman, Melissa M. Gibbons, Pi Phohomsiri, Jianxia
#' Cui, Darrell J. Swenson, and James H. Stuhmiller. “A Mechanistic End-to-End
#' Concussion Model That Translates Head Kinematics to Neurologic Injury.”
#' Frontiers in Neurology 8, no. JUN (2017): 1–18.
#' \doi{/10.3389/fneur.2017.00269}
#'
#' \item
#' Raymond, J. J. “Development of a Numerical Model to Predict Impact Forces on a
#' North Atlantic Right Whale during Collision with a Vessel.” University of New
#' Hampshire, 2007.
#' \url{https://scholars.unh.edu/thesis/309/}.
#'
#' \item
#' Soetaert, Karline, Thomas Petzoldt, and R. Woodrow Setzer.
#' “Solving Differential Equations in R: Package DeSolve.”
#' Journal of Statistical Software; Vol 1, Issue 9, 2010.
#' \doi{/10.18637/jss.v033.i09}.
#'
#' }
#'
#' @name whalestrike
#' @docType package
#' @keywords internal
"_PACKAGE"
NULL

#' Whale projected area, as function of length
#'
#' This depends on calculations based on the digitized shape of
#' a whale necropsy, which is provided as [whaleshape].
#' The results are
#' \eqn{0.143 * L^2}{0.143 * L^2}
#' for the projected area (see reference 1)
#' and
#' \eqn{0.448 * (0.877 * L)^2}{0.448 * (0.877 * L)^2}
#' for the wetted area
#' (see reference 2, but note that we use a correction related to whale mass).
#'
#' Note that multiple digitizations were done,
#' and that the coefficients used in the formulae
#' agreed to under 0.7 percent percent between these digitizations.
#'
#' @param L length in m.
#'
#' @param species A string indicating the whale species. For the permitted values,
#' see [whaleMassFromLength()].
#'
#' @param type character string indicating the type of area, with
#' `"projected"` for a side-projected area, and
#' `"wetted"` for the total wetted area. The wetted
#' area was computed by mathematically spinning a spline fit to the
#' side-view. In both cases, the original data source is the
#' necropsy side-view presented in Daoust et al. (2018).
#'
#' @references
#' 1. Dan Kelley's internal document `dek/20180623_whale_area.Rmd`, available
#' upon request.
#'
#' 2. Dan Kelley's internal document `dek/20180707_whale_mass.Rmd`, available
#' upon request.
#'
#' 3. Daoust, Pierre-Yves, Émilie L. Couture, Tonya Wimmer, and Laura Bourque.
#' “Incident Report. North Atlantic Right Whale Mortality Event in the Gulf of St.
#' Lawrence, 2017.” Canadian Wildlife Health Cooperative, Marine Animal Response
#' Society, and Fisheries and Oceans Canada, 2018.
#' \url{http://publications.gc.ca/site/eng/9.850838/publication.html}.
#' @author Dan Kelley
#'
#' @export
whaleAreaFromLength <- function(L, species = "N. Atl. Right Whale", type = "wetted") {
    speciesAllowed <- c("N. Atl. Right Whale")
    if (!(species %in% speciesAllowed)) {
        stop(
            "unknown species \"", species, "\"; use one of the following: \"",
            paste(speciesAllowed, collapse = "\", \""), "\""
        )
    }
    # below from dek/20180623_whale_area.Rmd, updated 20180802 and inserted with
    # cut/paste (changing bullet to asterisk, and using ^ for exponentiation).
    #
    # * Projected area, with fins: 0.1466 ∗ L^2 where L is body length in metres.
    # * Projected area, without fins: 0.1391 ∗ L^2 where L is body length in metres.
    # * Wetted area, with fins: 0.4631 ∗ L^2 where L is body length in metres.
    # * Wetted area, without fins: 0.4336 ∗ L^2 where L is body length in metres.
    #
    # The relevant case (with or without fins) being dependent on the application,
    # there may be merit in averaging the two estimates, yielding:
    # * Projected area: 0.1429 ∗ L^2 where L is body length in metres.
    # * Wetted area: 0.4484 ∗ L^2 where L is body length in metres.
    if (type == "projected") {
        0.143 * L^2
    } else if (type == "wetted") {
        0.448 * (0.877 * L)^2
    } else {
        stop("'type' must be 'projected' or 'wetted', but it is '", type, "'")
    }
}

#' Compute ship wetted area from mass
#'
#' Estimate the wetted area of a Cape Islander boat,
#' given the vessel mass.
#'
#' The method is based on scaling up the results for a single Cape
#' Islander ship, of displacement 20.46 tonnes, length 11.73m,
#' beam 4.63m, and draft 1.58m, on the assumption that the wetted area
#' is proportional to
#' \eqn{length*(2*draft+beam)}{length*(2*draft+beam)}.
#' This reference area is scaled to
#' the specified mass, `ms`, by multiplying by the 2/3
#' power of the mass ratio.
#'
#' Note that this is a crude calculation meant as a stop-gap measure, for
#' estimates values of the `Ss` argument to [parameters()].
#' It should not be used in preference to inferences
#' made from architectural drawings of a given ship under study.
#'
#' @param ms Ship mass (kg).
#'
#' @return Estimated area (m^2).
#'
#' @author Dan Kelley
#'
#' @export
shipAreaFromMass <- function(ms) {
    length <- 11.73 # m
    beam <- 4.63 # m
    draft <- 1.58 # m
    displacement <- 20.46e3 # m^3
    factor <- (ms / displacement)^(1 / 3) # lengthscale factor
    length * (beam + 2 * draft) * factor^2
}

#' Dynamical law
#'
#' This function handles Newton's second law, which is the dynamical
#' law that relates the accelerations of whale and ship to the forces
#' upon each.  It is used by [strike()], as the latter integrates
#' the acceleration equations to step forward in time through
#' the simulation of a whale-strike event. Thus, [dynamics()]
#' is a core function of this package.  The code is very simple,
#' because the forces are determined by other functions, as
#' described in the \dQuote{Details} section.
#'
#' Given a present state (defined by the positions and
#' velocities of ship and whale) at the present time,
#' apply Newton's second law to find the time derivatives
#' of that state.  Forces are determined with
#' [whaleCompressionForce()],
#' [whaleSkinForce()],
#' [shipWaterForce()],
#' [whaleWaterForce()], while engine force
#' (assumed constant over the course of a collision) is
#' computed from initial [shipWaterForce()].  Whale and
#' ship masses are set by [parameters()], which also sets up
#' areas, drag coefficients, etc.
#'
#' @param t time (s).
#'
#' @param y model state, a vector containing ship position `xs` (m),
#' ship speed `vs` (m/s), whale position `xw` (m),
#' and whale speed `vw` (m/s).
#'
#' @template parmsTemplate
#'
#' @references
#' See [whalestrike()] for a list of references.
#'
#' @author Dan Kelley
#'
#' @export
dynamics <- function(t, y, parms) {
    xs <- y[1] # ship position
    vs <- y[2] # ship velocity
    xw <- y[3] # whale position
    vw <- y[4] # whale velocity
    Fcompression <- whaleCompressionForce(xs, xw, parms)$force
    Fextension <- whaleSkinForce(xs, xw, parms)$force
    Freactive <- Fcompression + Fextension
    Fship <- if (!is.null(parms$engineForce)) {
        parms$engineForce + shipWaterForce(vs, parms) - Freactive
    } else {
        -Freactive
    }
    if (is.na(Fship[1])) {
        stop("Fship[1] is NA, probably indicating a programming error.")
    }
    Fwhale <- Freactive + whaleWaterForce(vw, parms)
    if (is.na(Fwhale[1])) {
        stop("Fwhale[1] is NA, probably indicating a programming error.")
    }
    list(c(dxsdt = vs, dvsdt = Fship / parms$ms, dxwdt = vw, dvwdt = Fwhale / parms$mw))
}

#' Simulate the collision of a ship and a whale
#'
#' Newtonian mechanics are used, taking the ship as non-deformable,
#' and the whale as being cushioned by a skin layer and a blubber layer.
#' The forces are calculated by
#' [shipWaterForce()],
#' [whaleSkinForce()],
#' [whaleCompressionForce()], and
#' [whaleWaterForce()] and the integration is carried out with
#' [deSolve::lsoda()].
#'
#' @param t a suggested vector of times (s) at which the simulated state will be reported.
#' This is only a suggestion, however, because `strike` is set up to detect high
#' accelerations caused by bone compression, and may set a finer reporting interval,
#' if such accelerations are detected. The detection is based on thickness of
#' compressed blubber and sublayer; if either gets below 1 percent
#' of the initial(uncompressed) value, then
#' a trial time grid is computed, with 20 points during the timescale for
#' bone compression, calculated as
#' \eqn{0.5*sqrt(Ly*Lz*a[4]*b[4]/(l[4]*mw)}{0.5*sqrt(Ly*Lz*a[4]*b[4]/(l[4]*mw)},
#' with terms as discussed in
#' the documentation for [parameters()]. If this trial grid is finer
#' than the grid in the `t` parameter, then the simulation is redone
#' using the new grid. Note that this means that the output will
#' be finer, so code should not rely on the output time grid being
#' @param state A list or named vector holding the initial state of the model:
#' ship position `xs` (m),
#' ship speed `vs` (m/s),
#' whale position `xw` (m),
#' and whale speed `vw` (m/s).
#'
#' @template parmsTemplate
#'
#' @template debugTemplate
#'
#' @return An object of class `"strike"`, consisting of a
#' list containing vectors for time (`t` (s)), ship position (`xs` (m)),
#' boat speed (`vs` (m/s)), whale position (`xw` (m)), whale speed (`vw` (m/s)),
#' boat acceleration (`dvsdt` (m/s^2)), and whale acceleration (`dvwdt` (m/s^2)),
#' a list containing the model parameters (`parms`), a list with the results of
#' the skin force calculation (`SWF`), a list with the results of the compression
#' force calculations (`WCF`), and a vector of whale water force (`WWF`).
#'
#' @examples
#' library(whalestrike)
#' # Example 1: graphs, as in the shiny app
#' t <- seq(0, 0.7, length.out = 200)
#' state <- list(xs = -2, vs = knot2mps(10), xw = 0, vw = 0) # ship speed 10 knots
#' parms <- parameters()
#' sol <- strike(t, state, parms)
#' par(mfcol = c(1, 3), mar = c(3, 3, 0.5, 2), mgp = c(2, 0.7, 0), cex = 0.7)
#' plot(sol)
#'
#' # Example 2: time-series plots of blubber stress and stress/strength,
#' # for a 200 tonne ship moving at 10 knots
#' t <- seq(0, 0.7, length.out = 1000)
#' state <- list(xs = -2, vs = knot2mps(10), xw = 0, vw = 0) # ship 10 knots
#' parms <- parameters(ms = 200 * 1000) # 1 metric tonne is 1000 kg
#' sol <- strike(t, state, parms)
#' par(mfrow = c(2, 1), mar = c(3, 3, 0.5, 2), mgp = c(2, 0.7, 0), cex = 0.7)
#' plot(t, sol$WCF$stress / 1e6, type = "l",
#'      xlab = "Time [s]", ylab = "Blubber stress [MPa]")
#' plot(t, sol$WCF$stress / sol$parms$s[2], type = "l",
#'      xlab = "Time [s]", ylab = "Blubber stress / strength")
#'
#' # Example 3: max stress and stress/strength, for a 200 tonne ship
#' # moving at various speeds. This is a slow calculation, so we do
#' # not run it by default.
#' \dontrun{
#' knots <- seq(0, 20, 0.5)
#' maxStress <- NULL
#' maxStressOverStrength <- NULL
#' for (speed in knot2mps(knots)) {
#'     t <- seq(0, 10, length.out = 1000)
#'     state <- list(xs = -2, vs = speed, xw = 0, vw = 0)
#'     parms <- parameters(ms = 200 * 1000) # 1 metric tonne is 1000 kg
#'     sol <- strike(t, state, parms)
#'     maxStress <- c(maxStress, max(sol$WCF$stress))
#'     maxStressOverStrength <- c(maxStressOverStrength, max(sol$WCF$stress / sol$parms$s[2]))
#' }
#' par(mfrow = c(2, 1), mar = c(3, 3, 0.5, 2), mgp = c(2, 0.7, 0), cex = 0.7)
#' nonzero <- maxStress > 0
#' plot(knots[nonzero], log10(maxStress[nonzero]),
#'     type = "o", pch = 20, xaxs = "i", yaxs = "i",
#'     xlab = "Ship Speed [knots]", ylab = "log10 peak blubber stress"
#' )
#' abline(h = log10(sol$parms$s[2]), lty = 2)
#' plot(knots[nonzero], log10(maxStressOverStrength[nonzero]),
#'     type = "o", pch = 20, xaxs = "i", yaxs = "i",
#'     xlab = "Ship Speed [knots]", ylab = "log10 peak blubber stress / strength"
#' )
#' abline(h = 0, lty = 2)
#' }
#'
#' @references
#' See [whalestrike()] for a list of references.
#'
#' @author Dan Kelley
#'
#' @export
#'
#' @importFrom deSolve lsoda
strike <- function(t, state, parms, debug = 0) {
    if (missing(t)) {
        stop("must supply t")
    }
    # Ensure that the state is well-configured, because the error messages
    # otherwise will be too cryptic for many users to fathom.
    if (missing(state)) {
        stop("must supply state")
    }
    if (4 != sum(c("xs", "vs", "xw", "vw") %in% names(state))) {
        stop("state must hold \"xs\", \"vs\", \"xw\", and \"vw\"")
    }
    if (is.list(state)) {
        state <- c(xs = state$xs, vs = state$vs, xw = state$xw, vw = state$vw)
    }
    if (missing(parms)) {
        stop("must supply parms")
    }
    if (!inherits(parms, "parameters")) {
        stop("parms must be the output of parameters()")
    }
    # Check parameters
    parmsRequired <- c(
        "a", "b", "Cs", "Cw", "l", "lsum", "lw", "Ly", "Lz",
        "ms", "mw", "s", "Ss", "stressFromStrain", "Sw",
        "theta"
    )
    if (!all(parmsRequired %in% names(parms))) {
        stop('parms must hold: "', paste(parmsRequired, collapse = '", "'), '"')
    }
    # All required elements are present, but it's prudent to check some values that
    # a user might be setting.
    if (!is.finite(parms$ms) || parms$ms <= 0) {
        stop("parms$ms (ship mass, in kg) must be a positive number, not ", parms$ms)
    }
    if (!is.finite(parms$mw) || parms$mw <= 0) {
        stop("parms$mw (whale mass, in kg) must be a positive number, not ", parms$mw)
    }
    if (!is.finite(parms$Ly) || parms$Ly <= 0) {
        stop("parms$Ly (impact width, in m) must be a positive number, not ", parms$Ly)
    }
    if (!is.finite(parms$Lz) || parms$Lz <= 0) {
        stop("parms$Lz (impact height, in m) must be a positive number, not ", parms$Lz)
    }
    if (!is.finite(parms$Cs) || parms$Cs <= 0) {
        stop("parms$Cs (drag coefficient of ship, dimensionless) must be a positive number, not ", parms$Cs)
    }
    if (!is.finite(parms$Cw) || parms$Cw <= 0) {
        stop("parms$Cw (drag coefficient of whale, dimensionless) must be a positive number, not ", parms$Cw)
    }
    if (!is.function(parms$stressFromStrain)) {
        stop("parms$stressFromStrain must be a function")
    }
    if (debug > 0) {
        print("state:")
        print(state)
        print("parms:")
        print(parms)
    }
    for (need in c("xs", "vs", "xw", "vw")) {
        if (!(need %in% names(state))) {
            stop(
                "state must contain item named '", need, "'; the names you supplied were: ",
                paste(names(state), collapse = " ")
            )
        }
    }
    parms["engineForce"] <- -shipWaterForce(state["vs"], parms) # assumed constant over time
    sol <- lsoda(state, t, dynamics, parms)
    # Add extra things for plotting convenience.
    t <- sol[, 1]
    xs <- sol[, 2]
    vs <- sol[, 3]
    xw <- sol[, 4]
    vw <- sol[, 5]
    dvsdt <- derivative(vs, t)
    dvwdt <- derivative(vw, t)
    SWF <- shipWaterForce(vs = vs, parms = parms)
    WSF <- whaleSkinForce(xs = xs, xw = xw, parms = parms)
    WCF <- whaleCompressionForce(xs = xs, xw = xw, parms = parms)
    WWF <- whaleWaterForce(vw = vw, parms = parms)
    # nolint start line_length_linter
    refinedGrid <- (min(WCF$compressed[, 2], na.rm = TRUE) / WCF$compressed[1, 2] < 0.01) || (min(WCF$compressed[, 3], na.rm = TRUE) / WCF$compressed[1, 3] < 0.01)
    # nolint end line_length_linter
    if (refinedGrid) {
        NEED <- 20 # desired number of points in peak
        dt <- (1 / NEED) * 0.5 * sqrt(parms$l[4] * parms$mw / (parms$Ly * parms$Lz * parms$a[4] * parms$b[4]))
        tstart <- t[1]
        tend <- tail(t, 1)
        nold <- length(t)
        n <- floor(0.5 * (tend - tstart) / dt)
        if (n > length(t)) {
            warning("increasing from ", nold, " to ", n, " time steps, to capture acceleration peak\n")
            t <- seq(tstart, tend, length.out = n)
            sol <- lsoda(state, t, dynamics, parms)
            # Add extra things for plotting convenience.
            t <- sol[, 1]
            xs <- sol[, 2]
            vs <- sol[, 3]
            xw <- sol[, 4]
            vw <- sol[, 5]
            dvsdt <- derivative(vs, t)
            dvwdt <- derivative(vw, t)
            SWF <- shipWaterForce(vs = vs, parms = parms)
            WSF <- whaleSkinForce(xs = xs, xw = xw, parms = parms)
            WCF <- whaleCompressionForce(xs = xs, xw = xw, parms = parms)
            WWF <- whaleWaterForce(vw = vw, parms = parms)
        }
    }
    res <- list(
        t = t, xs = xs, vs = vs, xw = xw, vw = vw,
        dvsdt = dvsdt, dvwdt = dvwdt,
        SWF = SWF, WSF = WSF, WCF = WCF, WWF = WWF,
        parms = parms,
        refinedGrid = refinedGrid
    )
    class(res) <- "strike"
    res
}

#' Summarize the parameters of a simulation, and its results
#'
#' @param object an object of class `"strike"`, as created by [strike()].
#'
#' @param \dots ignored
#'
#' @examples
#' library(whalestrike)
#' # Example 1: graphs, as in the shiny app
#' t <- seq(0, 0.7, length.out = 200)
#' state <- list(xs = -2, vs = knot2mps(10), xw = 0, vw = 0) # ship speed 10 knots
#' parms <- parameters()
#' sol <- strike(t, state, parms)
#' summary(sol)
#'
#' @author Dan Kelley
#'
#' @export
summary.strike <- function(object, ...) {
    parm <- object$parm
    summary(parm)
    LI <- lethalityIndexFromStress(object$WCF$stress)
    peakLI <- which.max(LI)
    cat("\nSimulation results returned by strike()\n")
    cat(sprintf("  simulated time range: 0 to %g s\n", max(object$t)))
    cat(sprintf("  xs: %12g m        -- ship position at t=0 s\n", object$xs[1]))
    cat(sprintf("  vs: %12.3g m/s      -- ship speed at t=0 s\n", object$vs[1]))
    cat(sprintf("      %12.3g knot     -- above, in a nautical unit\n", mps2knot(object$vs[1])))
    cat(sprintf("  lethality index had maximum value %.4g, at time %.4g s\n", LI[peakLI], object$t[peakLI]))
    timeOfDanger <- diff(range(object$t[LI > 0.5]))
    cat(sprintf("  lethality index exceeded 0.5 for %.4g s\n", timeOfDanger))
}
